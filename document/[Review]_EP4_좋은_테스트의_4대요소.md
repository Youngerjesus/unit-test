# 좋은 단위 테스트와 4대 요소

좋은 단위 테스트의 4대 요소는 다음과 같다.

- 회귀 방지
- 리팩터링 내성
- 빠른 피드백
- 유지보수 용이성

## 회귀 방지

회귀 방지는 소프트웨어 버그를 방지한다는 것이다.

코드가 복잡할수록, 실행되는 코드의 양이 많을수록, 도메인 영역의 코드일수록 이런 회귀 테스트는 필요하다.

- 단순한 코드는 딱히 테스트가 필요하지 않다.

그리고 중요한게 우리가 작성한 코드 뿐 아니라 라이브러리와 프레임워크를 사용하는 “우리가 작성하지 않은 코드" 에 대해서도 검증이 필요하다.

- 이것들이 항상 정상적으로 작동한다고 가정하지 말자.

회귀방지가 있어야 프로그램의 유지를 일으킬 수 있다. (안전성)

## 리팩터리 내성

리팩터링을 했는데 기존에 잘 작동하던 테스트가 실패하면 안된다. (정상 동작 but 그냥 실패만 하는 경우)

리팩터링 내성이 있어야 리팩터링 하기 쉽다.

이런 거짓 양성 (false positive) 는 올바른 정보를 전달해주지 않는다.

이런게 반복되다보면 우리는 문제가 났는데도 그걸 주의깊게 찾아보려고 하지 않을 것. (테스트에 대한 신뢰가 꺠진다.)

그래서 결론적으로 버그가 나도록 이끌것이다.

리팩터링 내성이 있어야 프로그램을 성장으로 이끌 수 있다. (성장성)

거짓 양성을 피할려면 테스트가 실제 객체의 세부 구현에 의존하지 않도록 하자.

변경되지 않는 부분인 추상화된 인터페이스에 대한 결과를 검증하자.

## 테스트 정확도

좋은 테스트 요소인 회귀 방지와 리팩터리 내성은 테스트 정확도를 높이는데 사용한다.

테스트 정확도를 낮추는 요인은 다음과 같다.

- 에러가 나야하는데 테스트가 성공하는 경우 (거짓 음성)
- 제대로 동작하는데 테스트가 실패하는 경우 (거짓 양성)

거짓 음성의 경우 회귀 방지가 해결해줄 수 있고 리팩터링 내성은 거짓 양성을 해결해주는데 도움을 준다.

## 빠른 피드백

테스트를 빠르게 실행시키고 버그라는 피드백을 빠르게 받을 수 있다면 버그를 고치는 비용은 엄청 줄어들 것이다.

이를 위해서 테스트는 빨리 실행되어야 한다.

## 유지 보수성

테스트 코드를 유지하는 비용을 말한다.

유지 비용은 다음과 같다.

- 테스트 코드가 읽기 쉬어야지 테스트 코드를 리팩터링하고 필요한 테스트를 보완할 수 있다.
- 테스트 코드를 실행하기 좋아야 한다. 실행하기 어려우면 테스트를 돌리기 어렵다.

## 테스트의 가치

테스트는 일반적으로 이 네가지 가치를 곱한 값이다. (즉 하나라도 0 이면 가치는 없다.)

## 극단적인 사례들

### 엔드 투 엔드 (E2E) 테스트

엔드 투 엔드 테스트는 최종 사용자 입장에서의 테스트이므로 회귀를 방지하는데 도움을 주고 리팩터링을 한다고 거짓 양성을 내지 않는다.

다만 빠른 피드백을 줄 수 없다. 그래서 버그가 난다면 버그 수정 비용이 엄청 클 것이다.

그리고 테스트를 작성할 때 필요한 설정들을 연결해야하는 작업이 클 것이므로 유지보수면에서도 비싸다.

### 간단한 테스트

간단한 테스트는 간단한 코드를 테스트 하는 것이므로 빠르다. 그리고 리팩터링 한다고 실패하지도 않을 것이다.

하지만 테스트 자체가 필요한 정보를 전달해주지 않는다.

회귀를 방지하는데 도움을 주지 않는다.

### 깨지기 쉬운 테스트

이런 테스트는 회귀를 방지할 확률이 높다. (거의 실패하므로 고치겠지.) 하지만 이런 테스트는 리팩터링 내성이 없다.

## 테스트 설계의 방향성

유지보수성은 코드를 짜는 개발자의 역량에 따라 다를 것이라서 배제를 하고 생각을 해보자.

리팩터링 내성도 OOP 기준 객체간의 결합을 얼마나 느슨하게 하느냐에 따라서 다르다. (뭘 검증하느냐에 따라서 다르기도 하겠지.)

OOP 기준 회귀를 방지한다는 것은 그만큼 많은 객체가 협력하고 있는 동작을 검증하겠다는 뜻이다. 대신에 그 만큼 느려진다.

**즉 회귀 방지와 피드백의 속도는 반비례한다.**

그러므로 리팩터링 내성은 신경쓰면서 회귀 방지 테스트와 빠른 피드백의 테스트 사이를 조율을 잘해야한다.

왔다갔다를 잘해야한다.

이것들을 고려해서 테스트를 짜다보면 테스트 피라미드를 이룬다.

- 단위 테스트의 수 > 통합 테스트의 수 > 엔드 투 엔드 테스트 수

일반적으로 엔드 투 엔드 테스트는 꼭 필요한 기능에만 둔다. (유지보수 비용과 속도면에서 엄청 안좋기 때문에.)

그리고 복잡하지 않은 알고리즘에서는 단위 테스트의 수는 줄어든다.
